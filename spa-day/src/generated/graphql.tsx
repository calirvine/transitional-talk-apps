import { gql } from '@apollo/client';
import * as Apollo from '@apollo/client';
export type Maybe<T> = T | null;
export type InputMaybe<T> = Maybe<T>;
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };
const defaultOptions = {} as const;
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: string;
  String: string;
  Boolean: boolean;
  Int: number;
  Float: number;
};

/** Autogenerated input type of AddArticle */
export type AddArticleInput = {
  body: Scalars['String'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  title: Scalars['String'];
};

/** Autogenerated input type of AddComment */
export type AddCommentInput = {
  articleId: Scalars['Int'];
  body: Scalars['String'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  commenter: Scalars['String'];
};

export type Article = {
  __typename?: 'Article';
  body: Scalars['String'];
  comments: CommentConnection;
  id: Scalars['ID'];
  title: Scalars['String'];
};


export type ArticleCommentsArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};

/** The connection type for Article. */
export type ArticleConnection = {
  __typename?: 'ArticleConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ArticleEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Article>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type ArticleEdge = {
  __typename?: 'ArticleEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Article>;
};

export type Comment = {
  __typename?: 'Comment';
  body: Scalars['String'];
  commenter: Scalars['String'];
  id: Scalars['ID'];
};

/** The connection type for Comment. */
export type CommentConnection = {
  __typename?: 'CommentConnection';
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<CommentEdge>>>;
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Comment>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
};

/** An edge in a connection. */
export type CommentEdge = {
  __typename?: 'CommentEdge';
  /** A cursor for use in pagination. */
  cursor: Scalars['String'];
  /** The item at the end of the edge. */
  node?: Maybe<Comment>;
};

/** Autogenerated input type of DeleteArticle */
export type DeleteArticleInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['ID'];
};

/** Autogenerated return type of DeleteArticle */
export type DeleteArticlePayload = {
  __typename?: 'DeleteArticlePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  success: Scalars['Boolean'];
};

export type Mutation = {
  __typename?: 'Mutation';
  addArticle?: Maybe<Article>;
  addComment?: Maybe<Comment>;
  deleteArticle?: Maybe<DeleteArticlePayload>;
  updateArticle?: Maybe<Article>;
  updateArticleBody?: Maybe<Article>;
  updateArticleTitle?: Maybe<Article>;
};


export type MutationAddArticleArgs = {
  input: AddArticleInput;
};


export type MutationAddCommentArgs = {
  input: AddCommentInput;
};


export type MutationDeleteArticleArgs = {
  input: DeleteArticleInput;
};


export type MutationUpdateArticleArgs = {
  input: UpdateArticleInput;
};


export type MutationUpdateArticleBodyArgs = {
  input: UpdateArticleBodyInput;
};


export type MutationUpdateArticleTitleArgs = {
  input: UpdateArticleTitleInput;
};

/** Information about pagination in a connection. */
export type PageInfo = {
  __typename?: 'PageInfo';
  /** When paginating forwards, the cursor to continue. */
  endCursor?: Maybe<Scalars['String']>;
  /** When paginating forwards, are there more items? */
  hasNextPage: Scalars['Boolean'];
  /** When paginating backwards, are there more items? */
  hasPreviousPage: Scalars['Boolean'];
  /** When paginating backwards, the cursor to continue. */
  startCursor?: Maybe<Scalars['String']>;
};

export type Query = {
  __typename?: 'Query';
  allArticles: ArticleConnection;
  articleById?: Maybe<Article>;
};


export type QueryAllArticlesArgs = {
  after?: InputMaybe<Scalars['String']>;
  before?: InputMaybe<Scalars['String']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
};


export type QueryArticleByIdArgs = {
  id: Scalars['Int'];
};

/** Autogenerated input type of UpdateArticleBody */
export type UpdateArticleBodyInput = {
  body: Scalars['String'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['ID'];
};

/** Autogenerated input type of UpdateArticle */
export type UpdateArticleInput = {
  body: Scalars['String'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['ID'];
  title: Scalars['String'];
};

/** Autogenerated input type of UpdateArticleTitle */
export type UpdateArticleTitleInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['ID'];
  title: Scalars['String'];
};

export type BlogArticleQueryVariables = Exact<{
  id: Scalars['Int'];
}>;


export type BlogArticleQuery = { __typename?: 'Query', articleById?: { __typename?: 'Article', id: string, title: string, body: string, comments: { __typename?: 'CommentConnection', nodes?: Array<{ __typename?: 'Comment', id: string, commenter: string, body: string } | null | undefined> | null | undefined } } | null | undefined };

export type DeleteBlogMutationVariables = Exact<{
  id: Scalars['ID'];
}>;


export type DeleteBlogMutation = { __typename?: 'Mutation', deleteArticle?: { __typename?: 'DeleteArticlePayload', success: boolean } | null | undefined };

export type AddCommentMutationVariables = Exact<{
  input: AddCommentInput;
}>;


export type AddCommentMutation = { __typename?: 'Mutation', addComment?: { __typename?: 'Comment', id: string, commenter: string, body: string } | null | undefined };

export type BlogScreenQueryVariables = Exact<{ [key: string]: never; }>;


export type BlogScreenQuery = { __typename?: 'Query', allArticles: { __typename?: 'ArticleConnection', nodes?: Array<{ __typename?: 'Article', id: string, title: string } | null | undefined> | null | undefined, pageInfo: { __typename?: 'PageInfo', hasNextPage: boolean, endCursor?: string | null | undefined, hasPreviousPage: boolean, startCursor?: string | null | undefined } } };

export type EditBlogMutationVariables = Exact<{
  input: UpdateArticleInput;
}>;


export type EditBlogMutation = { __typename?: 'Mutation', updateArticle?: { __typename?: 'Article', id: string, title: string, body: string, comments: { __typename?: 'CommentConnection', nodes?: Array<{ __typename?: 'Comment', id: string, commenter: string, body: string } | null | undefined> | null | undefined } } | null | undefined };

export type NewBlogMutationVariables = Exact<{
  input: AddArticleInput;
}>;


export type NewBlogMutation = { __typename?: 'Mutation', addArticle?: { __typename?: 'Article', id: string, title: string, body: string } | null | undefined };


export const BlogArticleDocument = gql`
    query BlogArticle($id: Int!) {
  articleById(id: $id) {
    id
    title
    body
    comments {
      nodes {
        id
        commenter
        body
      }
    }
  }
}
    `;

/**
 * __useBlogArticleQuery__
 *
 * To run a query within a React component, call `useBlogArticleQuery` and pass it any options that fit your needs.
 * When your component renders, `useBlogArticleQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useBlogArticleQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useBlogArticleQuery(baseOptions: Apollo.QueryHookOptions<BlogArticleQuery, BlogArticleQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<BlogArticleQuery, BlogArticleQueryVariables>(BlogArticleDocument, options);
      }
export function useBlogArticleLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<BlogArticleQuery, BlogArticleQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<BlogArticleQuery, BlogArticleQueryVariables>(BlogArticleDocument, options);
        }
export type BlogArticleQueryHookResult = ReturnType<typeof useBlogArticleQuery>;
export type BlogArticleLazyQueryHookResult = ReturnType<typeof useBlogArticleLazyQuery>;
export type BlogArticleQueryResult = Apollo.QueryResult<BlogArticleQuery, BlogArticleQueryVariables>;
export const DeleteBlogDocument = gql`
    mutation DeleteBlog($id: ID!) {
  deleteArticle(input: {id: $id}) {
    success
  }
}
    `;
export type DeleteBlogMutationFn = Apollo.MutationFunction<DeleteBlogMutation, DeleteBlogMutationVariables>;

/**
 * __useDeleteBlogMutation__
 *
 * To run a mutation, you first call `useDeleteBlogMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteBlogMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteBlogMutation, { data, loading, error }] = useDeleteBlogMutation({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useDeleteBlogMutation(baseOptions?: Apollo.MutationHookOptions<DeleteBlogMutation, DeleteBlogMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DeleteBlogMutation, DeleteBlogMutationVariables>(DeleteBlogDocument, options);
      }
export type DeleteBlogMutationHookResult = ReturnType<typeof useDeleteBlogMutation>;
export type DeleteBlogMutationResult = Apollo.MutationResult<DeleteBlogMutation>;
export type DeleteBlogMutationOptions = Apollo.BaseMutationOptions<DeleteBlogMutation, DeleteBlogMutationVariables>;
export const AddCommentDocument = gql`
    mutation AddComment($input: AddCommentInput!) {
  addComment(input: $input) {
    id
    commenter
    body
  }
}
    `;
export type AddCommentMutationFn = Apollo.MutationFunction<AddCommentMutation, AddCommentMutationVariables>;

/**
 * __useAddCommentMutation__
 *
 * To run a mutation, you first call `useAddCommentMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useAddCommentMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [addCommentMutation, { data, loading, error }] = useAddCommentMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useAddCommentMutation(baseOptions?: Apollo.MutationHookOptions<AddCommentMutation, AddCommentMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<AddCommentMutation, AddCommentMutationVariables>(AddCommentDocument, options);
      }
export type AddCommentMutationHookResult = ReturnType<typeof useAddCommentMutation>;
export type AddCommentMutationResult = Apollo.MutationResult<AddCommentMutation>;
export type AddCommentMutationOptions = Apollo.BaseMutationOptions<AddCommentMutation, AddCommentMutationVariables>;
export const BlogScreenDocument = gql`
    query BlogScreen {
  allArticles {
    nodes {
      id
      title
    }
    pageInfo {
      hasNextPage
      endCursor
      hasPreviousPage
      startCursor
    }
  }
}
    `;

/**
 * __useBlogScreenQuery__
 *
 * To run a query within a React component, call `useBlogScreenQuery` and pass it any options that fit your needs.
 * When your component renders, `useBlogScreenQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useBlogScreenQuery({
 *   variables: {
 *   },
 * });
 */
export function useBlogScreenQuery(baseOptions?: Apollo.QueryHookOptions<BlogScreenQuery, BlogScreenQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<BlogScreenQuery, BlogScreenQueryVariables>(BlogScreenDocument, options);
      }
export function useBlogScreenLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<BlogScreenQuery, BlogScreenQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<BlogScreenQuery, BlogScreenQueryVariables>(BlogScreenDocument, options);
        }
export type BlogScreenQueryHookResult = ReturnType<typeof useBlogScreenQuery>;
export type BlogScreenLazyQueryHookResult = ReturnType<typeof useBlogScreenLazyQuery>;
export type BlogScreenQueryResult = Apollo.QueryResult<BlogScreenQuery, BlogScreenQueryVariables>;
export const EditBlogDocument = gql`
    mutation EditBlog($input: UpdateArticleInput!) {
  updateArticle(input: $input) {
    id
    title
    body
    comments {
      nodes {
        id
        commenter
        body
      }
    }
  }
}
    `;
export type EditBlogMutationFn = Apollo.MutationFunction<EditBlogMutation, EditBlogMutationVariables>;

/**
 * __useEditBlogMutation__
 *
 * To run a mutation, you first call `useEditBlogMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useEditBlogMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [editBlogMutation, { data, loading, error }] = useEditBlogMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useEditBlogMutation(baseOptions?: Apollo.MutationHookOptions<EditBlogMutation, EditBlogMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<EditBlogMutation, EditBlogMutationVariables>(EditBlogDocument, options);
      }
export type EditBlogMutationHookResult = ReturnType<typeof useEditBlogMutation>;
export type EditBlogMutationResult = Apollo.MutationResult<EditBlogMutation>;
export type EditBlogMutationOptions = Apollo.BaseMutationOptions<EditBlogMutation, EditBlogMutationVariables>;
export const NewBlogDocument = gql`
    mutation NewBlog($input: AddArticleInput!) {
  addArticle(input: $input) {
    id
    title
    body
  }
}
    `;
export type NewBlogMutationFn = Apollo.MutationFunction<NewBlogMutation, NewBlogMutationVariables>;

/**
 * __useNewBlogMutation__
 *
 * To run a mutation, you first call `useNewBlogMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useNewBlogMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [newBlogMutation, { data, loading, error }] = useNewBlogMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useNewBlogMutation(baseOptions?: Apollo.MutationHookOptions<NewBlogMutation, NewBlogMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<NewBlogMutation, NewBlogMutationVariables>(NewBlogDocument, options);
      }
export type NewBlogMutationHookResult = ReturnType<typeof useNewBlogMutation>;
export type NewBlogMutationResult = Apollo.MutationResult<NewBlogMutation>;
export type NewBlogMutationOptions = Apollo.BaseMutationOptions<NewBlogMutation, NewBlogMutationVariables>;